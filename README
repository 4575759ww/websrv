
  0) Index
  ********

    0........Index
    1........About
    2........License
    3........Compiling The Source
      3.1....Feature Configuration
      3.2....Make Targets
    4........HTTP Server
      4.1....Command line
      4.2....Configuration Format
      4.3....Request path resolution
      4.4....HTTPS support
    5........Database Server
    6........JSON Parser & Serializer


  1) About
  ********

 This directory contains a REST framework/HTTP server written in C89, but
 utilizing Linux specific system calls and GNU library extensions to the
 utmost extent possible to keep the server small, simple and efficient.

 I developed this framework for university courses and private projects that
 required me to build a REST service or other web applications, after being
 annoyed with Tomcat+Jax-RS or similarly heavy weight C++ frameworks.

 Currently supported features:
  - Supports multiple virtual host configurations
  - Supports binding to different addresses/ports
  - Supports IPv4, IPv6 and UNIX domain sockets
  - Supports HTTP GET, HEAD, POST, PUT and DELETE methods
  - Supports HTTP keep-alive
  - Supports cookies
  - Guesses content-type from static files using file extension
  - Serve gzip compressed, static files if the client supports it
  - Dynamically generated data can be compressed on the fly
  - Use zero-copy splice syscall to serve static files
  - Tell clients to do caching on static files
  - Propperly handle If-Modified requests for static files
  - Map a specific path to REST service callback
  - Includes a simple JSON parser that generates C-structs from JSON
  - Includes a simple JSON serializer that genereats JSON from C-structs
  - Simple document/page templateing system
  - Minimal SQLite based data base server
  - Hard timeouts and limits on requests to guarntee that
    request handling terminates
  - Gracefully handles segfaults when serving requests. Log the request and
    send an error page.


 However, there are currently a few limitations:
  - Only absolute paths supported
  - No directory views (requests to directories are rejected)



  2) License
  **********

 For proprietary licensing options, please contact the author.


 The copy of the source code of the HTTP and Database servers that you
 received (all source files included in this directory and sub directories)
 are subject to the terms and conditions of the GNU AFFERO GENERAL PUBLIC
 LICENSE version 3.

 See LICENSE file for details.


  3) Compiling The Source
  ***********************

 Apart from a C compiler, a make binary and a shell, the data base server
 requires the SQLite library to be available for linking. The HTTP server
 requires the zlib library for compression of dynamic pages. The programs
 make heavy use of GNU library extensions and Linux specific system calls,
 so they should be available in the systems C standard library.

  3.1) Feature Configuration

 A hand written shell script named "configure" is provided in the root
 directory. The script generates configuration variables for the Makefile
 and writes them in a file called "Config".

 Various features of the server can be enabled or disabled via the command
 line, generating preprocessor definitions in a file called "config.h"

 The following command line switches can be used:
    --enable-json-parser
    --disable-json-parser
        Compile the server with or without JSON-to-C-struct deserializer.
        Default: enabled.

    --enable-json-serializer
    --disable-json-serializer
        Compile the server with or without C-struct-to-JSON serializer.
        Default: enabled.


  3.2) Make Targets

 To compile the source code, simply run 'make' in the source directory.

 The output can be cleaned up with a plain old 'make clean'.

 The output binaries can be stripped using 'make strip'.


  4) HTTP Server
  **************

  4.1) Command line

 To run the HTTP server, start it with the following command line arguments:
    --unix <bind>       Specify a UNIX domain socket to bind to.

    --port <num>        Set port number for TCP/IP sockets. Must be specified
                        _before_ --ipv4 and --ipv6.

    --ipv4 <bind>       Specify an IPv4 address to bind to. Use "ANY" to allow
                        all incoming connections. --port must be
                        specified before this.

    --ipv6 <bind>       Specify an IPv6 address to bind to. Use "ANY" to allow
                        all incoming connections. --port must be
                        specified before this.

    --cfg <configfile>  Specify a configuration file with virtual host
                        configuration. This option is required.

    --log <file>        Append logging output to a specific file

    --loglevel <num>    Higher level means more detailed/verbose output.
                        Possible values are:
                            0 - only print critical errors
                            1 - log critical errros and warnings (DEFAULT)
                            2 - also log generic information
                            3 - debug output


 The options --ipv4, --ipv6 and --unix can all be used all at the same time,
 and issued repeatedly. Each instance creates a further socket to bind to.
 The options --ipv4 and --ipv6 use the last port that was specified, so --port
 has to be specified at least once before them and can be respecified to set
 a different port for the following ones.


  4.2) Configuration Format

 The config file for the HTTP server is an .ini file with multiple "host"
 sections.

 Each "host" section can have the folowing keys:

    hostname    The value of the HTTP "Host:" request field to map.

    restdir     An optional, virtual directory to map to the internal
                callback system.

    datadir     An optional directory from which to server static files.

    templatedir An optional directory from which to load document
                template files.

    index       The virtual path to send when the client requests the
                document root ("/").


 A sample configuration is included with the source code.


  4.3) Request path resolution

 When a client requests a file, the server first tries to resolve it via the
 dynamic backend.

 If that backend returns a 404 response code, the server tries to serve a
 static file instead. This means, that the backend can override static files
 if it wants to.

 When resolving a static file and the client supports gzip compression, the
 server tries to append ".gz" to the path (unless the path already ends
 with *.gz). If that file exists, the server returns it _instead_ of the
 actually requested file and tells the client that it is gzip compressed.

 If that fails, the server tries to open the actual path and transfers
 that file. This allows serving precompressed files on the server if the
 client supports it, with a fallback to uncompressed files.

 If the requested path referes to a directory (or _anything_ other than a
 regular file), the server returns a "403 Forbidden" response.


 The server only tries to serve the index file, if the root document is
 requested (e.g. "GET /"). Serving the index file for arbitrary
 sub-directories, or serving directory views is not supported.


  4.4) HTTPS support

 The HTTP server itself does not support TLS connections. To support HTTPS
 connections, a TLS reverse proxy is required that redirects the unencrypted
 traffic to the HTTP server internally.

 A simple demo configuration is provided on how to use stunnel as an TLS
 wrapper on top of the HTTP server.

 Run "make cert" to generate private key, certificate and DH parameters for
 the server. Then run "stunnel ./tls.conf" to start up an TLS server that
 accepts connections on port 4040, servers the generated certificate and
 redirects the raw data to a Unix socket that the HTTP server provides.


  5) Database Server
  ******************

 To start the data base server, run 'rdb <dbfile> <unixsocket>' where <dbfile>
 is a place holder for the SQLite data base file to use and <unixsocket>
 specifies the path of a UNIX domain socket to create and bind to.


  6) JSON Parser & Serializer
  ***************************

 A parser for a limited subset of JSON is provided. It deserializes JSON
 directly to C structures in memory using a describtion table that can be
 generated semiautomatically via the preprocessor.

 The parser currently has the following limitations:

   - The parser only supports arrays of objects (not strings or integers)
   - Booleans are internally treated as integers
   - Floating point values are not supported
   - A JSON document must contain either an array or an object at the root
   - Objects and arrays must not be empty (i.e. contain at least one element)
   - Unknown JSON fields are skipped. Skiped fields may contain JSON values
     without any restrictions to the JSON grammar.


 In addition to the parser, a serializer is provided that can convert C
 structs directly to JSON strings.

