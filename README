
  0) Index
  ********

    0........Index
    1........About
    2........License
    3........Compiling The Source
    4........HTTP Server
      4.1....Command line
      4.2....Configuration Format
      4.3....HTTPS support
    5........Database Server
    6........JSON Parser & Serializer


  1) About
  ********

 This directory contains a REST framework/HTTP server written in C89, but
 utilizing Linux specific system calls and GNU library extensions to the
 utmost extent possible to keep the server small, simple and efficient.

 I developed this framework for university courses and private projects that
 required me to build a REST service or other web applications, after being
 annoyed with Tomcat+Jax-RS or similarly heavy weight C++ frameworks.

 Currently supported features:
  - Supports multiple virtual host configurations
  - Supports binding to different addresses/ports with different host mappings
  - Supports IPv4, IPv6 and UNIX domain sockets
  - Supports HTTP GET, HEAD, POST, PUT and DELETE methods
  - Supports HTTP keep-alive
  - Guesses content-type from static files using file extension
  - Serve deflate compressed, static files from a ZIP archive
  - Serve static files from a file system directory
  - Use zero-copy splice syscall to serve static files
  - Tell clients to do caching on static files
  - Propperly handle If-Modified requests for static files
  - Map a specific path to REST service callback
  - Supports cookies
  - Includes a simple JSON parser that generates C-structs from JSON
  - Includes a simple JSON serializer that genereats JSON from C-structs
  - Simple document/page templateing system
  - Dynamically generated data can be compressed on the fly
  - Minimal SQLite based data base server
  - Hard timeouts and limits on requests to guarntee that
    request handling terminates


 However, there are currently a few limitations:
  - Only absolute paths supported
  - No directory views (requests to directories are rejected)
  - ZIP files must be tightly packed (no polyglot bullshit)
  - All entries in a ZIP file must have size fields set
  - All entries in a ZIP file must be either uncompressed
    or deflate compressed
  - Encrypted ZIP files are not supported



  2) License
  **********

 For proprietary licensing options, please contact the author.


 The copy of the source code of the HTTP and Database servers that you
 received (all source files included in this directory and sub directories)
 are subject to the terms and conditions of the GNU AFFERO GENERAL PUBLIC
 LICENSE version 3.

 See LICENSE file for details.


  3) Compiling The Source
  ***********************

 Apart from a C compiler and make binary, the data base server requires the
 SQLite library to be available for linking. The programs make heavy use of
 GNU library extensions and Linux specific system calls, so they should be
 available in the systems C standard library.

 To compile the source code, simply run 'make' in the source directory.

 The output can be cleaned up with a plain old 'make clean'.

 The output binaries can be stripped using 'make strip'.



  4) HTTP Server
  **************

  4.1) Command line

 To run the HTTP server, start it with the following command line arguments:
    --unix <bind>       Specify a UNIX domain socket to bind to.

    --port <num>        Set port number for TCP/IP sockets. Must be specified
                        _before_ --ipv4 and --ipv6.

    --ipv4 <bind>       Specify an IPv4 address to bind to. Use "ANY" to allow
                        all incoming connections. --port must be
                        specified before this.

    --ipv6 <bind>       Specify an IPv6 address to bind to. Use "ANY" to allow
                        all incoming connections. --port must be
                        specified before this.

    --cfg <configfile>  Specify a configuration file with virtual host
                        configuration. This option is required.

 The options --ipv4, --ipv6 and --unix can all be used all at the same time,
 and issued repeatedly. Each instance creates a further socket to bind to.
 The options --ipv4 and --ipv6 use the last port that was specified, so --port
 has to be specified at least once before them and can be respecified to set
 a different port for the following ones.


  4.2) Configuration Format

 The config file for the HTTP server is an .ini file with multiple "host"
 sections.

 Each "host" section can have the folowing keys:

    hostname    The value of the HTTP "Host:" request field to map.

    restdir     An optional, virtual directory to map to the internal
                callback system.

    datadir     An optional directory from which to server static files.

    templatedir An optional directory from which to load document
                template files.

    index       The virtual path to send when the client requests the
                document root ("/").

    zip         An optional zip file to overlay over the data directory
                for serving static files.


 A sample configuration is included with the source code.


  4.3) HTTPS support

 The HTTP server itself does not support TLS connections. To support HTTPS
 connections, a TLS reverse proxy is required that redirects the unencrypted
 traffic to the HTTP server internally.

 A simple demo configuration is provided on how to use stunnel as an TLS
 wrapper on top of the HTTP server.

 Run "make cert" to generate private key, certificate and DH parameters for
 the server. Then run "stunnel ./tls.conf" to start up an TLS server that
 accepts connections on port 4040, servers the generated certificate and
 redirects the raw data to a Unix socket that the HTTP server provides.


  5) Database Server
  ******************

 To start the data base server, run 'rdb <dbfile> <unixsocket>' where <dbfile>
 is a place holder for the SQLite data base file to use and <unixsocket>
 specifies the path of a UNIX domain socket to create and bind to.


  6) JSON Parser & Serializer
  ***************************

 A parser for a limited subset of JSON is provided. It deserializes JSON
 directly to C structures in memory using a describtion table that can be
 generated semiautomatically via the preprocessor.

 The parser currently has the following limitations:

   - The parser only supports arrays of objects (not strings or integers)
   - Booleans are internally treated as integers
   - Floating point values are not supported
   - A JSON document must contain either an array or an object at the root
   - Objects and arrays must not be empty (i.e. contain at least one element)
   - Unknown JSON fields are skipped. Skiped fields may contain JSON values
     without any restrictions to the JSON grammar.


 In addition to the parser, a serializer is provided that can convert C
 structs directly to JSON strings.

